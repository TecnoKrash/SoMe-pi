
<document>
    <head>
        <title>Some-π test</title>
        <cowx>util.cowx</cowx>

        // Links in head don't work, so they are added manually in the body
    </head>
    <body>
        <!include-things/> // Links in head don't work, so they are added manually with this

        <!article-summary :_1=" " :_2=" "/>

        <main>
            <a href="tests.html">Navigate to test page</a>

            <br/>
            <br/>

            <h1> Interpolation in any dimension with barycentric coordinate </h1>
            
            <h2 id="intro"> Introduction </h2>

            <!hidden id="intro-other" :id="intro-other" :title="Other intro">
                This article presents a method to interpolate data. 
                Given a set of points, each of them representing the association of parameters (the inputs) with a value (the output),
                we want to predict what will happen for an input that is not present in the dataset.

                <br/>
                <br/>

                For instance, if a company wants to determine how efficient a machine is, depending on specific conditions (like temperature, used materials, etc),
                they measure it multiple times under different situations and then interpolate the results to guess what would happen is the cases that weren't tested.

                The goal is not to correct the measurements, nor to reduce noise in data, but simply to create a plausible continuous function
                from a set of points.

                We will try to solve a more specific problem, that doesn't allow many other methods:
                <ul>
                    <li>
                        the measures can be impacted by a potentially large number of independent parameters,
                    </li>
                    <li>
                        the measurements aren't equally distributed: the're not on a "grid" of predefined values, and there can be more points for some values than others,
                    </li>
                    <li>
                        and the partial derivatives of the output on the points aren't available.
                    </li>
                </ul>
            </hidden>

            Interpolation is a method used to create a new point in a data set without doing new mesurement, based on the original data set.
            It can be used simply to create a continuous function from a set of points to scaling up the framerate of a video. In this article, 
            we will focus on finding an efficient method that could be easaly generalised to mesure with a lot of parameters. 

            <br/>
            <br/>

            Here is our problem : we have a set of mesure that depend on a hight number of parameters that we optained with experimental mesurement.
            We can't do new mesurements, but we want to study what could happen to a particular parameters in a certain state of the other parameters.

            <br/>
            <br/>

            Let's say we have $n+1$ parameters, we will represent our mesure as point in an n-dimentional space (the coordinate of each point corespond to 
            the value of each parameters we want to fix), where each point contains a mesured value. We can now try to interpolate on 
            the particular points where we don't have any mesurement.

            <h2 id="visu">Visualization</h2>

            To visualize how each method produces results, we will use some interactive figure such as 
            <!pagelink :id="nearest">this one</pagelink>.

            It represents the problem with two parameters. 
            
            Each point you see (you can also drag them around) is a measure. It's X and Y coordinates are the value of its two parameters,
            and its color represent the measured value.

            Each pixel in the background indicates the result of the interpolation at its position.

            For this example, we used a very simple interpolation method: the output value is the value of the nearest measure. 

            <!figure id="nearest" :caption="Nearest neighbor interpolation"></figure>

            <h2 id="inverse-distance-title">Inverse distance</h2>

            We can start by trying a very simple method: the inverse distance weighting.
            If $A_0...A_n$ are the measures points and $§a_0...§a_n$ are their value, and we want to get a result on the point $M$, 
            we calculate:

            $$
                {|§S__{i=0}^^{n} a_i / {A_iM}} / {|§S__{j=0}^^{n} 1 / {A_jM}} 
            $$

            It's a weighted average, where the weights are the inverse distances between the points.
            This way, the more a point is far from $M$, the less it will impact the result.
            
            What if a distance is zero? Then it means that $M$ is directly on a measured point, so you can take its value instead.

            <!figure id="inverse-distance" :caption="Inverse distance interpolation"></figure> 

            <h2 id="pb-inverse-distance">Problems with inverse distance</h2>
            While this method seems at first to be doing well, it has some drawbacks.

            <br/>
            <br/>

            First, if there is a lot of points at the same place (if for instance you want more precision around a particular point),
            their values will impact the result more.
            
            <!figure :caption="Bad interpolation example">
                <div id="inverse-distance-fail-1" class="half-figure">
                    <div class="figure">
                        <inner></inner>
                    </div>
                </div>
                <div id="inverse-distance-fail-2" class="half-figure">
                    <div class="figure">
                        <inner></inner>
                    </div>
                </div>
            </figure>

            On the right, 4 additional measures have been made around the red point, and it impacts the results for the entire space!
            (the color of the borders aren't the same)
            The impact should instead be limited to the zone around the red point.

            <br/>
            <br/>

            This method has also another drawback: it takes all the points into account, event when it shouldn't.
            On the next figure you would expect the center of the screen to be completely blue, but the red point impacted the result and
            the center is purple-ish.
            <!figure id="inverse-distance-fail-3" :caption="Another bad interpolation example"></figure> 

            <h2 id="simpler-problem">A simpler problem</h2>

            Before trying another method, we will reduce the number of points.
            We will first interpolate in the simplest shape possible: in a triangle.
            If we're in a 3-dimensional space (with 3 parameters), it will be a tetrahedron, and if there are more 
            dimensions, the equivalent object.

            Generally speaking, in any dimension, this thing is called a <em>simplex</em>.

            <br/>
            <br/>

            We'll consider a non-degenerated simplex 
            (not completely flat, points aren't all contained in the same plane, meaning we can't find any n-1 dimention splice of the space where all the can fit)
            in dimension $n$ defined by the points $A_0 .. A_n$, and try to interpolate inside it.

            <br/>
            <br/>

            Fortunately, there is a nice tool for that: <em>barycentric coordinates</em>.

            <!def :title="Barycentric coordinates">
                Given a point $M$, $(§l_0 ... §l_n)$ are the barycentric coordinate of $M$ for $A_0...A_n$ if:
                
                $$
                    |§S__{k=0}^^{n} §l_k ?v{A_k M} = 0 ?txt{and} |§S__{k=0}^^{n} §l_k = 1
                $$
            </def>

            But what does it means? The first condition means that if you consider $§l_0 ... §l_n$ as weights on the points $A_0 ... A_n$,
            $M$ is the barycenter of these points.
            The second condition is there just for convenience.

            <!hidden id="bary-reformulate" :id="bary-reformulate" :title="Reformulation">
                If we consider another point $O$ as an origin then we have:
                $$
                    ?v{OM} = |§S__{k=0}^^{n} §l_k ?v{OA_k}
                $$

                $M$ is the weighted average of the points, and the weights are its barycentric coordinates.
            </hidden>

            For the mathematical proofs up ahead, we will provide simple explenations with interactive visualisation, as well as more formal proofs

            <!hidden id="formal-framework" :id="formal-framework" :title="Formal framework">

                For the formal proofs, we will represent our points in an Euclidian space, meaning an affine space $E$, 
                with the associated real vectorial space $?v E$ of dimention $n$, containing 
                an inner product $x . y = |§S__{k = 1}^^n x_k ?x y_k$ where $(x_1 ... x_n)$ and $(y_1 .. y_n)$ are the coordinate of the coresponding points.

            </hidden>


            <h2 id="barycentric-co-title">Why barycentric coordinates?</h2>

            First, we can prove that in a simplex (that is not degenerated), barycentric coordinates exist and are unique.

            For that, we will need to introduce what we'll called the "simplex base". To define a point in space, we often use an orthonormal base, 
            meaning a point O, being the origin of the space, and n unit vector (n is still the dimention of the space) all orthogonal to each other.
            But we don't actually need the base to be orthogonal for it to uniquely define each point of the space. The vectors can be of any legth,
            and be in any direction as long as they do not belong to the same plane .

            <br/>
            <br/>

            With that in mind, we can now construct a good base for our simplex. First we will take a random point of the simplex that we will 
            name $A_0$ and that will serve as the origine of the plane. We will then named all the other points $A_1$ to $A_n$ in a random order.

            For the vectors of the base we can now take ($?v{A_OA_1},...,?v{A_OA_n}$). From the properties of the simplex, we know that this 
            base is valid and that they don't belong to the same plane. you can convince yourself, or look at the proofs below. 
            From now on we will refer to this base as the "simplex base".


            <!hidden id="base-proof1" :id="base-proof1" :title="Basic explanation">

                Let's do a proof by contradiction. We suppose that we have a valid simplex in an n dimentional space, 
                and that the vectors $?v{A_OA_1},...,?v{A_OA_n}$ are contain in a same plain of n-1 dimention. 

                <br/>

                This means that any vectors optained by a linear composition of those vector will be contained in that plain as well. 
                we can optain a vector linking any two points $A_i$, $A_j$ of the simplex by doing $?v{A_0A_j} - ?v{A_0A_i} = ?v{A_iA_j}$.

                #TODO
            </hidden>

            
            <!hidden id="base-proof2" :id="base-proof2" :title="Real proof">
                We can do a recurcive proof on $n$ :
                <br/>
                - if $n = 1$, a simplex is a line, and there is only two point $A_0$ and $A_1$. if $A_0 != A_1$ then $?v{A_0A_1} != ?v0$
                <br/>
                - Let's suppose that for some $n € ||N$, any given simplex in n dimention, the vectors 

                #TODO

            </hidden>

            We will now use the simplex base to build the barycentric coordinate of a point $M$, located in the simplex, for each vertex.

            First we know that there exists $(x_k)_{k € [1, n]}$ so that:   
            
            $$
                ?v{A_0M} = |§S__{k = 1}^^n x_k ?v{A_0A_k}
            $$

            (This is the representation of $M$ in the  simplex base.)

            Here all the vectors are comming from $A_0$, but we want them to come from $M$ (like in the definition of barycentric coordinates).
            Thus what we can do is adding $?v{MA_0}$ on both side of the equation to recenter all the vectors 
            (using the fact that $?v{MA_0} =  |§S__{k = 1}^^n x_k ?v{MA_0}  + (1 - |§S__{k = 1}^^n §x_k) ?v{MA_0}$):

            $$
                ?v{MA_0} + ?v{A_0M} &= |§S__{k = 1}^^n x_k ?v{MA_0}  + (1 - |§S__{k = 1}^^n x_k) ?v{MA_0} + |§S__{k = 1}^^n x_k ?v{A_0A_k}&&
                ?v 0 &= |§S__{k = 1}^^n x_k ?v{MA_k}  + (1 - |§S__{k = 1}^^n x_k) ?v{MA_0}&&
            $$

            We almost have the good expretion. We just need to set for all $k € [0 ; n]$ 
            $$
                y_k = <!system style="vertical-align: middle;">
                    \ 1 - |§S__{k=1}^^n x_k & ?txt{if} k = 0 &&
                    \ x_k & ?txt{otherwise}
                </system>
            $$

            This gives us what we want :
            $$
                |§S__{k = 1}^^n y_k ?v{MA_k}  = ?v 0

            $$

            and the segond condition is also verified : $|§S__{k=0}^^n y_k = 1$

            <br/>

            More that proving the existence of barycentric coordinates in a simplex, 
            we've shown that for all the vertex $A_k$ appart from the origin, the coordinate of that vertex is equal to the coefficient $x_k$ 
            the vector to this vertex $?v{A_0A_k}$ in the simplex base. This property will be usefull later.


            <!hidden id="existence-proof2" :id="existence-proof2" :title="Rigourous existence proof">
                
                <h4>Existence</h4>

                Let $(A_k)_{k € [0, n]} € E^{n + 1}$, so that $(?v{A_0A_k})_{k € [1, n]}$ is a basis of $?v E$.
                (We say that $(A_0 ... A_n)$ form an affine basis).
                These points represent a non degenerated simplex.
                Let $M € E$.
                There exists $(§a_k)_{k € [1, n]}$ so that:
                $$
                    ?v{A_0M} = |§S__{k=1}^^n §a_k (?v{A_0A_k})
                $$

                Thus:
                $$
                    ?v{OM} = |§S__{k=1}^^n §a_k ?v{OA_k} + ?v{OA_0}(1 - |§S__{k=1}^^n §a_k)
                $$

                We can then define:
                $$
                    ?a k € [0; n], §b_k = <!system style="vertical-align: middle;">
                        1 - |§S__{k=1}^^n §a_k & ?txt{if} k = 0 &&
                        §a_k & ?txt{otherwise}
                    </system>
                $$

                And so we have
                $$
                    ?v{OM} &= |§S__{k=0}^^n §b_k ?v{OA_k} &&
                    |§S__{k=0}^^n §b_k ?v{OM} &= |§S__{k=0}^^n §b_k ?v{OA_k} ?txt{Because} |§S__{k=0}^^n §b_k = 1 &&
                    |§S__{k=0}^^n §b_k ?v{MA_k} &= 0
                $$


                That satisfies the definition of barycentric coordinates:
                $$
                    M = |{bar}((A_k, §b_k)_{k € [0, n]}) ?txt{and} |§S__{k=0}^^n §b_k = 1
                $$

                <h4>Uniqueness</h4>
                
                Let $M € E$, we suppose that $(a_k)_{k € [0, n]}$ et $(b_k)_{k € [0, n]}$ are barycentric coordinates for $M$ in $(A_k)_{k € [0, n]}$.
                We have then:
                $$
                    |§S__{k=0}^^n §a_k ?v{MA_k} = |§S__{k=0}^^n §b_k ?v{MA_k}
                $$

                Then:
                $$
                    |§S__{k=0}^^n ?v{MA_k} (§a_k - §b_k) &= 0 &&
                    |§S__{k=0}^^n ?v{A_0M} (§a_k - §b_k) + |§S__{k=0}^^n ?v{MA_k} (§a_k - §b_k) &= 0 &&
                    |§S__{k=0}^^n ?v{A_0A_k} (§a_k - §b_k) &= 0
                $$

                But $(?v{A_0A_1} ... ?v{A_0A_n})$ form a basis of $?v E$, so for all $k € [0 ; n]$, $§a_k - §b_k = 0 <=> a_k = b_k$

            </hidden> 

            We can also make a few remarks:
            <ul>
                <li>
                    If $M$ is on $A_k$, then its coordinate for $k$ is $1$, the others are $0$.
                    For interpolation, if we use its coordinates as weights for the measures, we will obtain the value of $A_k$,
                    and this is what we're looking for. 
                </li>
                <li>
                    If $M$ is the center of gravity of the simplex (the average of all the points), its barycentric coordinates
                    will all be equal to $1 / {n + 1}$ where $n$ is the dimension. This is also coherent.
                </li>
            </ul>

            That make them good candidates for interpolation. As we will see in the next paragraph, they're also easy to compute.

            <h2 id="barycentric-co-in-simplex">Barycentric coordinates in a simplex </h2>

            As we saw before, the barycentric coordinate of a vertex $A_k$ is equal to the coefficient $x_k$ of the vector to this vertex $?v{A_0A_k}$ 
            in the simplex base. Thus, we just need to find  an expression for that coefficient. If we take all the other vertices
            of the simplex, we know that they define a plane $P_k$, and that $A_k$ is the only point out of it. This means that $?v{A_0A_k}$ is the only 
            contributing to the normal direction from the plane $P_k$ (we will represent this direction by the normal vector $?v n$)
            We have 
            $$
                x_k ?x ?v{A_0A_k}.?v n = ?v{A_0M}.?v n
            $$
            
            Since the direction is the same, we can take the norm on both sides : 

            $$
                x_k ?x ?norm{?v{A_0A_k}.?v n} = ?norm{?v{A_0M}.?v n}
            $$

            $?norm{?v{A_0A_k}.?v n}$ is just the height of the simplex and $?norm{?v{A_0M}.?v n}$ is just the height of M.

            Thus we have 

            $$
                x_k = {|{Height\ of\ }?txt{M}}/{|{Height\ of\ }A_k}
            $$

            Just below is a visualization of the situation for a 2-simplex (a triangle). The blue lines are the vector representing 
            $M$ in the simplex base, and the green lines represent the heights of $M$, the yellow line the height of $A_k$.

            <!figure id="barycentric-height" :caption="Coefficient visualisation">
                <div class="figure-math">
                    $
                        x_k = {|{Height\ of\ }M}/{|{Height\ of\ }\ A_k}
                            = {<%span id="bh-frac-top" style="color: #00ff00">999</span>} / {<%span id="bh-frac-btm" style="color: #ffff00">999</span>}
                            = <%span id="bh-res">999</span>
                    $
                </div>
            </figure>


            <!hidden id="expression-proof2" :id="expression-proof2" :title="Complete proof">
                
                Let set for all $k € [1, n]$, $b_k = (?v{A_0A_k})$.  $(b_1 ... b_n) \\ {b_k}$ defines a hyperplane $£B_k$ of $?v E$. 
                We will name $P_k$ the associated plane in $E$.

                <br/>

                Let $H$ be the orthogonal projection of $M$ on $£B_k$
                and $K$ the orthogonal projection of $A_k$ on $£B_k$.

                <br/>
                <br/>

                Let $k € [1, n]$.
                We have : 
                $$
                    ?v{A_0M} = |§S__{i = 1}^^n x_i ?v{A_0A_i} &&
                    ?v{A_0M} = |§S__{i € [1, n] \\ {k}}^^n x_i ?v{A_0A_i} + x_k ?v{A_0A_k}
                $$
                Where $(x_i)_{i € [0 ; n]}$ are the barycentric coordinate of $M$ in $(A_0 ... A_n)$

                Let $?v n$ the normal vector of $£B_k$ pointing towards $A_k$.

                We have:
                $$
                    x_k ?v{A_0A_k} . ?v n &= ?norm{?v{HM}} &&
                    x_k ?v{A_0A_k} . ?v{n} &= ?norm{?v{HM}} &&
                    x_k ?v{KA_k} . ?v{n} + ?v{A_0K} . ?v{n} &= ?norm{?v{HM}}
                $$

                Then $K$ and $A_0$ are both in $P_k$, and $?v{KA_k}$ and $?v{HM}$ are both normal to $£B_k$.
                $$
                    x_k ?x ?norm{?v{KA_k}} &= ?norm{?v{HM}}&&
                $$

                This gives us the expression of $x_k$ :
                $$
                    x_k = { ?norm{?v{HM}} } / { ?norm{?v{KA_k}} }
                $$

                Now by following the proof of the existence of the coordinates, we have $§l_k = x_k$.
            </hidden>

            <h2 id="area-and-volume">Area and volume</h2>

            Since in 2 dimensions, the area of a triangle is ${|{base} ?x |{height}} / 2$, we can reformulate the expression:
            Let $l != m != k$

            $$
                x_k &= {|{Height\ of\ }?txt{M}}/{|{Height\ of\ }A_k} &&
                    &= { £A(A_l A_m M)} / {£A(A_l A_m A_k)}
            $$

            So this is the quotient of the area of the whole triangle with $A_k$ replaced by $M$, by the area of the whole triangle.

            Here is an example:
    
            <!figure id="barycentric-area" :caption="Barycentric coordinates with area">
                <div class="figure-math">
                    $
                        {|{blue\ area}} / {|{gray\ area}}
                        = {<%span id="ba-frac-top" style="color: #0000ff">999</span>} / {<%span id="ba-frac-btm" style="color: #777">999</span>}
                        = <%span id="ba-res">999</span>
                    $
                </div>
            </figure>

            It work the same in 3 dimensions: the coordinates are the quotient of the volumes.

            <!figure id="barycentric-volume" :caption="Barycentric coordinates with volume">
                <div class="figure-math">
                    $
                        {|{blue\ volume}} / {|{total\ volume}}
                        = {<%span id="bv-frac-top" style="color: #0000ff">999</span>} / {<%span id="bv-frac-btm" style="color: #777">999</span>}
                        = <%span id="bv-res">999</span>
                    $
                </div>
            </figure>

            It makes sense because the sum of the small areas/volumes will be the total simplex area/volume, so the sum
            of the coordinates will be $1$.

            You can finally that it works well for interpolation:

            <!figure id="single-simplex" :caption="Barycentric interpolation in one simplex"></figure> 

            Since we stayed very generic all the way, this method works in any dimention !

            <h2 id="cloud-of-points"> Interpolation in a cloud of points </h2>

            Even tho barycentric interpolation works very well, the case presented above isn't very practical : we only have n points and a small 
            zone where we can interpolate. What we would like is to be able to interpolate in any cloud of points on a large area.

            <br/>
            <br/>

            We can try to triangulate the space with those points (choose simplexes that cover the entier space), but there are some drawbacks:
            <ul>
                <li>
                    First, there isn't one way to do that (see figures below);
                </li>
                <li>
                    The triangulation algorithms are already complicated in two dimensions, doing it in any dimention is probably very difficult;
                </li>
                <li>
                    If the interpolation happens on a single point, there is no need to compute triangulation on the whole space,
                    it would be more efficient to just consider simplexes around the point.
                </li>
            </ul>

            <!figure :caption="Two different interpolations">
                <div id="triangulation-1" class="half-figure">
                    <div class="figure">
                        <inner></inner>
                    </div>
                </div>
                <div id="triangulation-2" class="half-figure">
                    <div class="figure">
                        <inner></inner>
                    </div>
                </div>
            </figure>

            Also, bad triangulations can lead to terrible interpolation results.
            
            <!figure id="triangulation-bad" :caption="A terrible triangulation"></figure> 

            <br/>
            <br/>

            Another idea can be to take the $n$ nearest points to form a simplex.
            However there is cases where the formed simplex is not containing the point.  

            <!figure id="outside-triangle" :caption="The white point is not the the triangle formed by the 3 nearest points"></figure> 

            <h2 id="last-method">The final method</h2>

            To get better result, we can try interpolating in multiple simplexes.
            We can select an arbitrary amount of simplexes that contains the point, and get the average of their interpolations.
            To pick the best simplexes, there are multiple criteria:
            <ul>
                <li>Select simplexes with the smallest volume,</li>
                <li>with the smallest surface,</li>
                <li>or with the smallest ${|{surface}}/{|{volume}}$ quotient (to prevent stretched simplexes).</li>
            </ul>

            The choice of criteria and the amount of simplexes to consider should be adapted to the nature of the interpolation problem:
            some datasets can be more adapted to a specific method.

            <br/>
            <br/>

            Here is an example with the volume criterium, with 2 simplexes used to interpolate:

            <!figure id="final-interpolation" :caption="Average of interpolations of the 2 smallest simplexes" class="half-figure">
            </figure>
        </main>
    </body>
</document>



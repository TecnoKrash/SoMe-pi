
<document>
    <head>
        <title>Some-π test</title>
        <cowx>util.cowx</cowx>

        // Links in head don't work, so they are added manually in the body
    </head>
    <body>
        <!include-things/> // Links in head don't work, so they are added manually with this

        <!article-summary :_1=" " :_2=" "/>

        <main>
            <h1> Interpolation in any dimension with barycentric coordinates </h1>
            
            <h2 id="intro"> Introduction </h2>

            <!hidden id="intro-other" :id="intro-other" :title="Other intro">
                This article presents a method to interpolate data. 
                Given a set of points, each of them representing the association of parameters (the inputs) with a value (the output),
                we want to predict what will happen for an input that is not present in the dataset.

                <br/>
                <br/>

                For instance, if a company wants to determine how efficient a machine is, depending on specific conditions (like temperature, used materials, etc),
                they measure it multiple times under different situations and then interpolate the results to guess what would happen is the cases that weren't tested.

                The goal is not to correct the measurements, nor to reduce noise in data, but simply to create a plausible continuous function
                from a set of points.

                We will try to solve a more specific problem, that doesn't allow many other methods:
                <ul>
                    <li>
                        the measures can be impacted by a potentially large number of independent parameters,
                    </li>
                    <li>
                        the measurements aren't equally distributed: the're not on a "grid" of predefined values, and there can be more points for some values than others,
                    </li>
                    <li>
                        and the partial derivatives of the output on the points aren't available.
                    </li>
                </ul>
            </hidden>


            <!hidden id="intro-other-other" :id="intro-other-other" :title="another intro">
                Interpolation is a method used to create a new point in a data set without doing new mesurement, based on the original data set.
                It can be used simply to create a continuous function from a set of points to scaling up the framerate of a video. In this article, 
                we will focus on finding an efficient method that could be easaly generalised to mesure with a lot of parameters. 

                <br/>
                <br/>

                Here is our problem : we have a set of mesure that depend on a hight number of parameters that we optained with experimental mesurement.
                We can't do new mesurements, but we want to study what could happen to a particular parameters in a certain state of the other parameters.

                <br/>
                <br/>

                Let's say we have $n+1$ parameters, we will represent our mesure as point in an n-dimentional space (the coordinate of each point corespond to 
                the value of each parameters we want to fix), where each point contains a mesured value. We can now try to interpolate on 
                the particular points where we don't have any mesurement.
            </hidden>

            Interpolation is a method used to create a new point in a data set without doing new measurements, using the existing points.
            It can be used simply to create a continuous function from a set of points to scaling up the framerate of a video. In this article, 
            we will try to find an efficient method that could be able to handle a lot of parameters. 

            <br/>
            <br/>

            Here is our problem : a company wants to determine how efficient a machine is, depending on various conditions (like temperature, materials properties, etc).
            The company makes multiple measures under different situations and then interpolate the results to guess what would happen is the cases that weren't tested.

            The goal is not to correct the measurements, nor to reduce noise in data, but simply to create a plausible continuous function
            from the set of points.

            Mre precisely, we will try to solve a more specific problem, that is hard to resolve with other methods:
            <ul>
                <li>
                    the measures can be impacted by a potentially large number of independent parameters,
                </li>
                <li>
                    the measurements aren't equally distributed: the're not on a "grid" of predefined values, and there can be more points around some values than others,
                </li>
                <li>
                    and the partial derivatives of the output on the points aren't available.
                </li>
            </ul>

            <br/>


            Let's say we have $n$ parameters, we will represent each measure as a point in an n-dimensional space: the coordinates of the point will correspond to 
            the value of each parameter during the measure, and each point will be associated with its measured value. We can now try to interpolate on 
            points where we don't have any measurement.

            <h2 id="visu">Visualization</h2>

            To visualize how each method produces results, we will use some interactive figure such as 
            <!pagelink :id="nearest">this one</pagelink>.

            It represents the problem with two parameters. 
            
            Each point you see (you can also drag them around) is a measure. It's X and Y coordinates are the value of its two parameters,
            and its color represent the measured value.

            Each pixel in the background indicates the result of the interpolation at its position.

            For this example, we used a very simple interpolation method: the output value is the value of the nearest measure. 

            <!figure id="nearest" :caption="Nearest neighbor interpolation"></figure>

            <h2 id="inverse-distance-title">Inverse distance</h2>

            We can start by trying a very simple method: the inverse distance weighting.
            If $A_0...A_n$ are the measures points and $§a_0...§a_n$ are their value, and we want to get a result on the point $M$, 
            we calculate:

            $$
                {|§S__{i=0}^^{n} a_i / {A_iM}} / {|§S__{j=0}^^{n} 1 / {A_jM}} 
            $$

            It's a weighted average, where the weights are the inverse distances between the points.
            This way, the more a point is far from $M$, the less it will impact the result.
            
            What if a distance is zero? Then it means that $M$ is directly on a measured point, so you can take its value instead.

            <!figure id="inverse-distance" :caption="Inverse distance interpolation"></figure> 

            <h2 id="pb-inverse-distance">Problems with inverse distance</h2>
            While this method seems at first to be doing well, it has some drawbacks.

            <br/>
            <br/>

            First, if there is a lot of points at the same place (if for instance you want more precision around a particular point),
            their values will impact the result more.
            
            <!figure :caption="Bad interpolation example">
                <div id="inverse-distance-fail-1" class="half-figure">
                    <div class="figure">
                        <inner></inner>
                    </div>
                </div>
                <div id="inverse-distance-fail-2" class="half-figure">
                    <div class="figure">
                        <inner></inner>
                    </div>
                </div>
            </figure>

            On the right, 4 additional measures have been made around the red point, and it impacts the results for the entire space!
            (the color of the borders aren't the same)
            The impact should instead be limited to the zone around the red point.

            <br/>
            <br/>

            This method has also another drawback: it takes all the points into account, event when it shouldn't.
            On the next figure you would expect the center of the screen to be completely blue, but the red point impacted the result and
            the center is purple-ish.
            <!figure id="inverse-distance-fail-3" :caption="Another bad interpolation example"></figure> 

            <h2 id="simpler-problem">A simpler problem</h2>

            Before trying another method, we will reduce the number of points.
            We will first interpolate in the simplest shape possible: in a triangle.
            If we're in a 3-dimensional space (with 3 parameters), it will be a tetrahedron, and if there are more 
            dimensions, the equivalent object.

            Generally speaking, in any dimension, this thing is called a <em>simplex</em>.

            <br/>
            <br/>

            We'll consider a non-degenerated simplex 
            (not completely flat, points aren't all contained in the same plane, meaning we can't find any n-1 dimention splice of the space where all the can fit)
            in dimension $n$ defined by the points $A_0 .. A_n$, and try to interpolate inside it.

            <br/>
            <br/>

            Fortunately, there is a nice tool for that: <em>barycentric coordinates</em>.

            <!def :title="Barycentric coordinates">
                Given a point $M$, $(§l_0 ... §l_n)$ are the barycentric coordinate of $M$ for $A_0...A_n$ if:
                
                $$
                    |§S__{k=0}^^{n} §l_k ?v{A_k M} = 0 ?txt{and} |§S__{k=0}^^{n} §l_k = 1
                $$
            </def>

            But what does it means? The first condition means that if you consider $§l_0 ... §l_n$ as weights on the points $A_0 ... A_n$,
            $M$ is the barycenter of these points.
            The second condition is there just for convenience.

            <!hidden id="bary-reformulate" :id="bary-reformulate" :title="Reformulation">
                If we consider another point $O$ as an origin then we have:
                $$
                    ?v{OM} = |§S__{k=0}^^{n} §l_k ?v{OA_k}
                $$

                $M$ is the weighted average of the points, and the weights are its barycentric coordinates.
            </hidden>

            For the mathematical proofs up ahead, we will provide simple explenations with interactive visualisation, as well as more formal proofs

            <!hidden id="formal-framework" :id="formal-framework" :title="Formal framework">

                For the formal proofs, we will represent our points in an Euclidian space, meaning an affine space $E$, 
                with the associated real vectorial space $?v E$ of dimention $n$, containing 
                an inner product $x . y = |§S__{k = 1}^^n x_k ?x y_k$ where $(x_1 ... x_n)$ and $(y_1 .. y_n)$ are the coordinate of the coresponding points.

            </hidden>


            <h2 id="barycentric-co-title">Why barycentric coordinates?</h2>

            We can first make a few remarks:
            <ul>
                <li>
                    If $M$ is on $A_k$, then its coordinate for $k$ is $1$, the others are $0$.
                    For interpolation, if we use its coordinates as weights for the measures, we will obtain the value of $A_k$,
                    and this is what we're looking for. 
                </li>
                <li>
                    If $M$ is the center of gravity of the simplex (the average of all the points), its barycentric coordinates
                    will all be equal to $1 / {n + 1}$ where $n$ is the dimension. This is also coherent.
                </li>
            </ul>

            That make them good candidates for interpolation. We can also prove that for all points in a simplex
            (that is not degenerated), these coordinates exists and are unique. We will also see later that they're easy to compute.

            <br/>
            <br/>

            But first, we'll introduce a base of the space.

            <br/>

            To define a point in space, we often use an orthonormal base, 
            meaning a point $O$, being the origin of the space, and $n$ unit vector ($n$ is dimension of the space) all orthogonal to each other.
            But we don't actually need the base to be orthogonal for it to uniquely define each point of the space. The vectors can be of any lengths,
            and can be in any direction as long as they do not belong to the same plane.

            <br/>
            <br/>

            With that in mind, we can now construct a convenient base to define our points. First we will take a random point of the simplex that we will 
            name $A_0$. It will be the origin of the plane. We will then name all the other points $A_1$ to $A_n$.

            <br/>
            <br/>

            The vectors ($?v{A_OA_1},...,?v{A_OA_n}$) will define the base. From the properties of the simplex, we know that this 
            base is valid and that the vectors don't belong to the same plane (see proofs below).
            From now on we will refer to this base as the "simplex base".

            <!hidden id="base-proof1" :id="base-proof1" :title="Explanation">
                Let's do a proof by contradiction. We suppose that we have a valid simplex in an n dimensional space, 
                and that the vectors $?v{A_OA_1},...,?v{A_OA_n}$ are contained in a $n-1$ dimensional plane $£P$. 
                (we need a point to fully describe this plain, we will take $A_0$). 

                <br/>
                <br/>

                Since $A_0$ is the origine of $£P$, $A_0$ is contain in $£P$.
                So for all $k € [0 , n]$, $A_0$ and $?v{A_0A_k}$ are contained in $£P$ witch means $A_k$ is contained in $£P$ as well.

                <br/>
                <br/>

                This mean that all the vertices of the simplex are contained in $£Q$. The simplex is thus degenerated (it is completely flat); 
                this is a contradiction, so our hypothesis is false and the vectors $?v{A_OA_1},...,?v{A_OA_n}$ are not contained in a $n-1$ dimensional plane.
            </hidden>
 
            <!hidden id="base-proof2" :id="base-proof2" :title="Precision to be rigorous">
                The proof above is correct but we need to do a little precision:
                <br/>
                - <em>the vectors $?v{A_OA_1},...,?v{A_OA_n}$ are contained in a $n-1$ dimensional plane $£P$.</em>

                <br/>
                    To be more exact, the vectors form an hyperplane $H$ of dimension $n-1$ in $?v E$, witch is associated
                    to the corresponding plane $£P$ in $E$, witch will pass through the center of the space. 
                    We've set the center to $A_0$, so everything after that is correct.
            </hidden>

            We will now use the simplex base to build the barycentric coordinate of a point $M$, located in the simplex, for each vertex.

            First we know that there exists $(x_k)_{k € [1, n]}$ so that:   
            
            $$
                ?v{A_0M} = |§S__{k = 1}^^n x_k ?v{A_0A_k}
            $$

            (This is the representation of $M$ in the simplex base.)

            Here all the vectors are all relative to $A_0$, but we want them to be relative to $M$ (to match the definition of barycentric coordinates).
            Thus we can add $?v{MA_0}$ on both side of the equation:
            (using the fact that $?v{MA_0} =  |§S__{k = 1}^^n x_k ?v{MA_0}  + (1 - |§S__{k = 1}^^n x_k) ?v{MA_0}$):

            $$
                ?v{MA_0} + ?v{A_0M} &= ?v{MA_0} + §S__{k = 1}^^n x_k ?v{A_0A_k} &&
                ?v 0                &= ?v{MA_0} (1 - |§S__{k = 1}^^n x_k + |§S__{k = 1}^^n x_k) + §S__{k = 1}^^n x_k ?v{A_0A_k} &&
                ?v 0                &= ?v{MA_0} (1 - |§S__{k = 1}^^n x_k) + §S__{k = 1}^^n x_k (?v{MA_0} + ?v{A_0A_k}) &&
                ?v 0                &= ?v{MA_0} (1 - |§S__{k = 1}^^n x_k) + §S__{k = 1}^^n x_k (?v{MA_k})
            $$

            We can thee this looks like the definition. We just need to set for all $k € [0 ; n]$ 
            $$
                y_k = <!system style="vertical-align: middle;">
                    \ 1 - |§S__{k=1}^^n x_k & ?txt{if} k = 0 &&
                    \ x_k & ?txt{otherwise}
                </system>
            $$

            This gives us what we want :
            $$
                |§S__{k = 1}^^n y_k ?v{MA_k}  = ?v 0

            $$

            The second condition is also verified : $|§S__{k=0}^^n y_k = 1$

            <br/>

            We proved the existence of barycentric coordinates in a simplex! 
            We've shown that for all the vertex $A_k$ (except the origin), the coordinate for that vertex is equal to the coefficient $x_k$. 
            This property will be useful later.

            <br/>
            <br/>

            To prove that these coordinates are unique, here is a boring proof:

            <!hidden id="existence-proof2" :id="existence-proof2" :title="Uniqueness proof">
                
                <h4>Existence</h4>

                Let $(A_k)_{k € [0, n]} € E^{n + 1}$, so that $(?v{A_0A_k})_{k € [1, n]}$ is a basis of $?v E$.
                (We say that $(A_0 ... A_n)$ form an affine basis).
                These points represent a non degenerated simplex.
                Let $M € E$.
                There exists $(§a_k)_{k € [1, n]}$ so that:
                $$
                    ?v{A_0M} = |§S__{k=1}^^n §a_k (?v{A_0A_k})
                $$

                Thus:
                $$
                    ?v{OM} = |§S__{k=1}^^n §a_k ?v{OA_k} + ?v{OA_0}(1 - |§S__{k=1}^^n §a_k)
                $$

                We can then define:
                $$
                    ?a k € [0; n], §b_k = <!system style="vertical-align: middle;">
                        1 - |§S__{k=1}^^n §a_k & ?txt{if} k = 0 &&
                        §a_k & ?txt{otherwise}
                    </system>
                $$

                And so we have
                $$
                    ?v{OM} &= |§S__{k=0}^^n §b_k ?v{OA_k} &&
                    |§S__{k=0}^^n §b_k ?v{OM} &= |§S__{k=0}^^n §b_k ?v{OA_k} ?txt{Because} |§S__{k=0}^^n §b_k = 1 &&
                    |§S__{k=0}^^n §b_k ?v{MA_k} &= 0
                $$


                That satisfies the definition of barycentric coordinates:
                $$
                    M = |{bar}((A_k, §b_k)_{k € [0, n]}) ?txt{and} |§S__{k=0}^^n §b_k = 1
                $$

                <h4>Uniqueness</h4>
                
                Let $M € E$, we suppose that $(a_k)_{k € [0, n]}$ et $(b_k)_{k € [0, n]}$ are barycentric coordinates for $M$ in $(A_k)_{k € [0, n]}$.
                We have then:
                $$
                    |§S__{k=0}^^n §a_k ?v{MA_k} = |§S__{k=0}^^n §b_k ?v{MA_k}
                $$

                Then:
                $$
                    |§S__{k=0}^^n ?v{MA_k} (§a_k - §b_k) &= 0 &&
                    |§S__{k=0}^^n ?v{A_0M} (§a_k - §b_k) + |§S__{k=0}^^n ?v{MA_k} (§a_k - §b_k) &= 0 &&
                    |§S__{k=0}^^n ?v{A_0A_k} (§a_k - §b_k) &= 0
                $$

                But $(?v{A_0A_1} ... ?v{A_0A_n})$ form a basis of $?v E$, so for all $k € [0 ; n]$, $§a_k - §b_k = 0 <=> a_k = b_k$

            </hidden> 

            <h2 id="barycentric-co-in-simplex">Barycentric coordinates in a simplex </h2>

            As we saw before, the barycentric coordinate of a vertex $A_k$ is equal to the coefficient $x_k$ of the vector to this vertex $?v{A_0A_k}$ 
            in the simplex base. Thus, we just have to find an expression for that coefficient. If we take all the other vertices
            of the simplex, we know that they define a plane $P_k$, and that $A_k$ is the only point out of it. 
            This means that $?v{A_0A_k}$ is the only vector not perpendicular to $?v n$, the unit normal vector of $£P$ pointing towards $A_k$.
            We have 
            $$
                ?v{A_0M}.?v n = (|§S__{i=1}^^{n} x_i ?v{A_0A_i}).?v n = (x_k ?x ?v{A_0A_k}). ?v n = x_k (?v{A_0A_k}. ?v n)
            $$

            $?v{A_0A_k}.?v n$ is just the height of the simplex and $?v{A_0M}.?v n$ is just the height of M.

            Thus we have 

            $$
                x_k = {|{Height\ of\ }?txt{M}}/{|{Height\ of\ }A_k}
            $$

            Just below is a visualization of the situation for a 2-simplex (a triangle). The blue lines are the vector representing 
            $M$ in the simplex base, and the green lines represent the heights of $M$, the yellow line the height of $A_k$.

            <!figure id="barycentric-height" :caption="Coefficient visualisation">
                <div class="figure-math">
                    $
                        x_k = {|{Height\ of\ }M}/{|{Height\ of\ }\ A_k}
                            = {<%span id="bh-frac-top" style="color: #00ff00">999</span>} / {<%span id="bh-frac-btm" style="color: #ffff00">999</span>}
                            = <%span id="bh-res">999</span>
                    $
                </div>
            </figure>


            <!hidden id="expression-proof2" :id="expression-proof2" :title="Complete proof">
                
                Let set for all $k € [1, n]$, $b_k = (?v{A_0A_k})$.  $(b_1 ... b_n) \\ {b_k}$ defines a hyperplane $£B_k$ of $?v E$. 
                We will name $P_k$ the associated plane in $E$.

                <br/>

                Let $H$ be the orthogonal projection of $M$ on $£B_k$
                and $K$ the orthogonal projection of $A_k$ on $£B_k$.

                <br/>
                <br/>

                Let $k € [1, n]$.
                We have : 
                $$
                    ?v{A_0M} = |§S__{i = 1}^^n x_i ?v{A_0A_i} &&
                    ?v{A_0M} = |§S__{i € [1, n] \\ {k}}^^n x_i ?v{A_0A_i} + x_k ?v{A_0A_k}
                $$
                Where $(x_i)_{i € [0 ; n]}$ are the barycentric coordinate of $M$ in $(A_0 ... A_n)$

                Let $?v n$ the normal vector of $£B_k$ pointing towards $A_k$.

                We have:
                $$
                    x_k ?v{A_0A_k} . ?v n &= ?norm{?v{HM}} &&
                    x_k ?v{A_0A_k} . ?v{n} &= ?norm{?v{HM}} &&
                    x_k ?v{KA_k} . ?v{n} + ?v{A_0K} . ?v{n} &= ?norm{?v{HM}}
                $$

                Then $K$ and $A_0$ are both in $P_k$, and $?v{KA_k}$ and $?v{HM}$ are both normal to $£B_k$.
                $$
                    x_k ?x ?norm{?v{KA_k}} &= ?norm{?v{HM}}&&
                $$

                This gives us the expression of $x_k$ :
                $$
                    x_k = { ?norm{?v{HM}} } / { ?norm{?v{KA_k}} }
                $$

                Now by following the proof of the existence of the coordinates, we have $§l_k = x_k$.
            </hidden>

            <h2 id="area-and-volume">Area and volume</h2>

            Since in 2 dimensions, the area of a triangle is ${|{base} ?x |{height}} / 2$, we can reformulate the expression:
            Let $l != m != k$

            $$
                x_k &= {|{Height\ of\ }?txt{M}}/{|{Height\ of\ }A_k} &&
                    &= { £A(A_l A_m M)} / {£A(A_l A_m A_k)}
            $$

            So this is the quotient of the area of the whole triangle with $A_k$ replaced by $M$, by the area of the whole triangle.

            Here is an example:
    
            <!figure id="barycentric-area" :caption="Barycentric coordinates with area">
                <div class="figure-math">
                    $
                        {|{blue\ area}} / {|{gray\ area}}
                        = {<%span id="ba-frac-top" style="color: #0000ff">999</span>} / {<%span id="ba-frac-btm" style="color: #777">999</span>}
                        = <%span id="ba-res">999</span>
                    $
                </div>
            </figure>

            It work the same in 3 dimensions: the coordinates are the quotient of the volumes.

            <!figure id="barycentric-volume" :caption="Barycentric coordinates with volume">
                <div class="figure-math">
                    $
                        {|{blue\ volume}} / {|{total\ volume}}
                        = {<%span id="bv-frac-top" style="color: #0000ff">999</span>} / {<%span id="bv-frac-btm" style="color: #777">999</span>}
                        = <%span id="bv-res">999</span>
                    $
                </div>
            </figure>

            It makes sense because the sum of the small areas/volumes will be the total simplex area/volume, so the sum
            of the coordinates will be $1$.

            You can finally that it works well for interpolation:

            <!figure id="single-simplex" :caption="Barycentric interpolation in one simplex"></figure> 

            Since we stayed very generic all the way, this method works in any dimension !

            <h2 id="cloud-of-points"> Interpolation in a cloud of points </h2>

            Even tho barycentric interpolation works very well, the case presented above isn't very practical : we only have n points and a small 
            zone where we can interpolate. What we would like is to be able to interpolate in any cloud of points on a large area.

            <br/>
            <br/>

            We can try to triangulate the space with those points (choose simplexes that cover the entier space), but there are some drawbacks:
            <ul>
                <li>
                    First, there isn't one way to do that (see figures below);
                </li>
                <li>
                    The triangulation algorithms are already complicated in two dimensions, doing it in any dimention is probably very difficult;
                </li>
                <li>
                    If the interpolation happens on a single point, there is no need to compute triangulation on the whole space,
                    it would be more efficient to just consider simplexes around the point.
                </li>
            </ul>

            <!figure :caption="Two different interpolations">
                <div id="triangulation-1" class="half-figure">
                    <div class="figure">
                        <inner></inner>
                    </div>
                </div>
                <div id="triangulation-2" class="half-figure">
                    <div class="figure">
                        <inner></inner>
                    </div>
                </div>
            </figure>

            Also, bad triangulations can lead to terrible interpolation results.
            
            <!figure id="triangulation-bad" :caption="A terrible triangulation"></figure> 

            <br/>
            <br/>

            Another idea can be to take the $n$ nearest points to form a simplex.
            However there is cases where the formed simplex is not containing the point.  

            <!figure id="outside-triangle" :caption="The white point is not the the triangle formed by the 3 nearest points"></figure> 

            <h2 id="last-method">The final method</h2>

            To get better result, we can try interpolating in multiple simplexes.
            We can select an arbitrary amount of simplexes that contains the point, and get the average of their interpolations.
            To pick the best simplexes, there are multiple criteria:
            <ul>
                <li>Select simplexes with the smallest volume,</li>
                <li>with the smallest surface,</li>
                <li>or with the smallest ${|{surface}}/{|{volume}}$ quotient (to prevent stretched simplexes).</li>
            </ul>

            The choice of criteria and the amount of simplexes to consider should be adapted to the nature of the interpolation problem:
            some datasets can be more adapted to a specific method.

            <br/>
            <br/>

            Here is an example with the volume criterion, with 2 simplexes used to interpolate:

            <!figure id="final-interpolation" :caption="Average of interpolations of the 2 smallest simplexes">
            </figure>

            As you can see, the algorithm creates seams around points that are near the border of a triangle.
            Also, the algorithm seems to try interpolating in stretched triangles, resulting in the blue stripes and purple stripes around the center.
            
            <br/>
            <br/>

            We can try to fix that by making a weighted average. Let $S$ be the set of all simplexes that contains the point to interpolate. 
            We also define $w$ a function that takes a simplex and returns a criterion as described above,
            and $i$ a functions that returns the interpolated value in the simplex. We can then output:

            $$
                { |§S__{S € A} { i(s) } / { w(s) ^ n } } / { |§S__{S € A} { 1 } / { w(s) ^ n } }
            $$ 

            Here, $w$ returns the surface of the simplex, and $n = 2$:

            <!figure id="weighted-interpolation" :caption="Interpolation with average of multiple simplexes">
            </figure>

            The result is not perfect, but if seams are really a problem, it is still possible to smooth the results
            by calculating the interpolation on multiple points around the desired value. 

            <h2 id="conclusion"> Conclusion </h2>

                Even if we focused a lot on 2D example (most notably to be able to show the value of all the points we can interpolate with colors),
                one of the biggest advantages of this method is its capability to be generalized to any dimension. 

                <br/>

                Even if we choose a very specific problem at the beginning, the way we used barycentric coordinate in simplexes around the point to interpolate
                make it very flexible on what you want to do, compared to the other method we presented at the beginning.It lets you decide how to use the 
                interpolation values in different simplexes to get the final result, as we showed in the last section.

                <br/>
                <br/>

                There are still some drawbacks to this method, as it his much heavier to compute than the simple methods we presented at the beginning 
                (even if it stays reasonable), and it can only interpolate in the convex enveloppe of the points (meaning the 
                interior of the shape created if you connect all the outer points of the cloud).


            <h2 id="source"> Links and source code </h2>

            If you are really interested, here is  an implementation of this method, as well as the source code of the website:
            <br/>
            <a href="https://github.com/TecnoKrash/SoMe-pi">Github repository</a>
            
            <br/>
            <br/>

            A video explaining how to find the volume of a simplex in any dimension, that we used in the last section:
            <br/>
            <a href="https://github.com/TecnoKrash/SoMe-pi">Finding the volume of a simplex (YouTube)</a>
            
            <br/>
            <br/>

            This article presents a method to have barycentric coordinates in shapes that are more complicated than simplexes, which could be
            a great solution to get better results:
            <br/>
            <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3549276/">Error Estimates for Generalized Barycentric Interpolation</a>


        </main>
    </body>
</document>


